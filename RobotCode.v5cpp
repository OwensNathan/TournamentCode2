#pragma region VEXcode Generated Robot Configuration
// Make sure all required headers are included.
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>
#include "vex.h"


using namespace vex;
//Brain should be defined by default
brain Brain;


// START V5 MACROS
#define waitUntil(condition)                                                   \
  do {                                                                         \
    wait(5, msec);                                                             \
  } while (!(condition))


#define repeat(iterations)                                                     \
  for (int iterator = 0; iterator < iterations; iterator++)
// END V5 MACROS


// Robot configuration code.


// generating and setting random seed
void initializeRandomSeed(){
  int systemTime = Brain.Timer.systemHighResolution();
  double batteryCurrent = Brain.Battery.current();
  double batteryVoltage = Brain.Battery.voltage(voltageUnits::mV);


  // Combine these values into a single integer
  int seed = int(batteryVoltage + batteryCurrent * 100) + systemTime;


  // Set the seed
  srand(seed);
}


void vexcodeInit() {
  //Initializing random seed.
  initializeRandomSeed();
}


// Helper to make playing sounds from the V5 in VEXcode easier and
// keeps the code cleaner by making it clear what is happening.
void playVexcodeSound(const char *soundName) {
  printf("VEXPlaySound:%s\n", soundName);
  wait(5, msec);
}


#pragma endregion VEXcode Generated Robot Configuration


#include <cmath>
#include <cstdlib>
#include <cstdio>


using namespace vex;


/******************************************************************************
*  VEX V5 Robot Code â€“ Push Back 2026
*  Author: Nathan Owens, Caitlin Ndambuki
*  Tournament-Ready Version
*  CONTROLS:
*    - Left Joystick (Axis3): Forward/Backward
*    - Right Joystick (Axis1): Turn Left/Right
*    - L1/L2: Lift control (L1=up, L2=down)
*    - R1/R2: Intake control (R1=out, R2=in)
*    - A/B: Arm control
*    - ButtonUp: Lift preset to max height
*    - ButtonRight: Lift preset to middle height
*    - ButtonDown: Lift preset to bottom height
*
*  PORT CONFIGURATION:
*  1 - Intake (blue)
*  2 - Arm (blue)
*  3 - Right Lift (red) LiftR
*  4 - Back Right Motor (blue) R1
*  9 - Left Lift (red) LiftL
*  10 - Back left driver (blue) L1
*  12 - Front right driver (blue) R2
*  20 - Front left (blue) L2
******************************************************************************/


/*================== GLOBAL OBJECTS ==================*/
controller  Controller;
competition Competition;


/*================== DRIVE MOTORS ==================*/
motor L1(PORT10, ratio36_1, true);
motor L2(PORT20, ratio36_1, true);
motor R1(PORT4, ratio36_1, false);
motor R2(PORT12, ratio36_1, false);


/*================== LIFT MOTORS ==================*/
motor LiftL(PORT9, ratio36_1, false);
motor LiftR(PORT3, ratio36_1, true);


/*================== ARM & INTAKE MOTORS ==================*/
motor Arm(PORT2, ratio36_1, true);
motor Intake(PORT1, ratio36_1, false);




/*================== HELPER FUNCTIONS ==================*/
// Smooth ramp: current -> target at given step
double ramp(double current, double target, double step) {
   if (current < target) {
       current += step;
       if (current > target) current = target;
   } else if (current > target) {
       current -= step;
       if (current < target) current = target;
   }
   return current;
}


/*================== PRE-AUTONOMOUS ==================*/
void pre_auton() {
   // Motor stopping modes
   L1.setStopping(coast); L2.setStopping(coast);
   R1.setStopping(coast); R2.setStopping(coast);
   LiftL.setStopping(hold); LiftR.setStopping(hold);
   Arm.setStopping(hold); Intake.setStopping(hold);


   // Reset motor positions
   L1.setPosition(0, degrees); L2.setPosition(0, degrees);
   R1.setPosition(0, degrees); R2.setPosition(0, degrees);
   LiftL.setPosition(0, degrees); LiftR.setPosition(0, degrees);
   Arm.setPosition(0, degrees); Intake.setPosition(0, degrees);
}


/*================== AUTONOMOUS ==================*/
void autonomous() {
   L1.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, false);
   L2.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, false);
   R1.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, false);
   R2.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, true);
   Intake.spinFor(forward, 3, rotationUnits::rev);


   LiftL.spinFor(forward, 3, rotationUnits::rev);
   LiftR.spinFor(forward, 3, rotationUnits::rev);
   L1.spinFor(0.5, rotationUnits::rev, 50, velocityUnits::pct, true);
   L2.spinFor(0.5, rotationUnits::rev, 50, velocityUnits::pct, true);
   R1.spinFor(0.5, rotationUnits::rev, 50, velocityUnits::pct, true);
   R2.spinFor(0.5, rotationUnits::rev, 50, velocityUnits::pct, false);


   L1.spinFor(0.5, rotationUnits::rev, 50, velocityUnits::pct, true);
   L2.spinFor(0.5, rotationUnits::rev, 50, velocityUnits::pct, true);


   L1.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, false);
   L2.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, false);
   R1.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, false);
   R2.spinFor(3, rotationUnits::rev, 50, velocityUnits::pct, true);
   LiftL.spinFor(forward, 3, rotationUnits::rev);
   LiftR.spinFor(forward, 3, rotationUnits::rev);
   Intake.spinFor(reverse, 2, rotationUnits::rev);
}


/*================== LIFT CONSTANTS ==================*/
const double LIFT_MAX_POS    = 900;   // full up position (ButtonUp)
const double LIFT_MIDDLE_POS = 131;   // middle position (ButtonRight)
const double LIFT_MIN_POS    = 0;     // bottom position (ButtonDown) - LOWERED


/*================== DRIVER CONTROL ==================*/
void usercontrol() {
  const double DEADZONE = 10;

  // Ramping state
  double leftPowerCurrent  = 0;
  double rightPowerCurrent = 0;
  double liftCurrent       = 0;
  double armCurrent        = 0;

  const double DRIVE_STEP = 5;
  const double LIFT_STEP  = 5;
  const double ARM_STEP   = 10;

  // Lift preset control
  double liftTargetPosition = -1; // -1 means no active preset
  const double LIFT_kP = 0.8;
  const double LIFT_TOLERANCE = 10;

  int hudCounter = 0;

  while (true) {
    //==================== DRIVE (always active) ====================
    double forward = Controller.Axis3.position(); // forward/back
    double turn    = Controller.Axis1.position(); // left/right

    if (fabs(forward) < DEADZONE) forward = 0;
    if (fabs(turn) < DEADZONE) turn = 0;

    double leftTarget  = forward + turn;
    double rightTarget = forward - turn;

    // Clamp
    if (leftTarget > 100) leftTarget = 100;
    if (leftTarget < -100) leftTarget = -100;
    if (rightTarget > 100) rightTarget = 100;
    if (rightTarget < -100) rightTarget = -100;

    leftPowerCurrent  = ramp(leftPowerCurrent, leftTarget, DRIVE_STEP);
    rightPowerCurrent = ramp(rightPowerCurrent, rightTarget, DRIVE_STEP);

    L1.spin(fwd, leftPowerCurrent, pct);
    L2.spin(fwd, leftPowerCurrent, pct);
    R1.spin(fwd, rightPowerCurrent, pct);
    R2.spin(fwd, rightPowerCurrent, pct);

    //==================== LIFT (manual overrides presets) ====================
    // Read position
    double currentLiftPos =
      (LiftL.position(degrees) + LiftR.position(degrees)) / 2.0;

    // Manual input (highest priority for lift)
    double liftManual = 0;
    bool liftManualActive = false;

    if (Controller.ButtonL1.pressing()) {
      liftManual = 100;
      liftManualActive = true;
      liftTargetPosition = -1; // cancel any preset
    } else if (Controller.ButtonL2.pressing()) {
      liftManual = -50;
      liftManualActive = true;
      liftTargetPosition = -1; // cancel any preset
    }

    // Preset buttons only apply if NOT manually controlling lift
    // (Once pressed, they stay latched via liftTargetPosition.)
    if (!liftManualActive) {
      if (Controller.ButtonUp.pressing()) {
        liftTargetPosition = LIFT_MAX_POS;
      } else if (Controller.ButtonRight.pressing()) {
        liftTargetPosition = LIFT_MIDDLE_POS;
      } else if (Controller.ButtonDown.pressing()) {
        liftTargetPosition = LIFT_MIN_POS;
      }
    }

    // Apply lift power continuously (this is what makes presets actually work)
    const char* liftModeText = "HOLD/IDLE";
    if (liftManualActive) {
      liftModeText = "MANUAL";

      // Safety limits for manual (allow going to 0)
      if (currentLiftPos < 0 && liftManual < 0) liftManual = 0;
      if (currentLiftPos > LIFT_MAX_POS && liftManual > 0) liftManual = 0;

      liftCurrent = ramp(liftCurrent, liftManual, LIFT_STEP);
    } else if (liftTargetPosition >= 0) {
      liftModeText = "PRESET";

      double error = liftTargetPosition - currentLiftPos;
      double power = error * LIFT_kP;

      // Clamp
      if (power > 100) power = 100;
      if (power < -100) power = -100;

      // Stop at target
      if (fabs(error) < LIFT_TOLERANCE) power = 0;

      liftCurrent = power;
    } else {
      liftCurrent = ramp(liftCurrent, 0, LIFT_STEP);
    }

    LiftL.spin(fwd, liftCurrent, pct);
    LiftR.spin(fwd, liftCurrent, pct);

    //==================== ARM (independent) ====================
    double armTarget = 0;
    const char* armText = "STOP";
    if (Controller.ButtonA.pressing()) {
      armTarget = 50;
      armText = "A (UP/FWD)";
    } else if (Controller.ButtonB.pressing()) {
      armTarget = -50;
      armText = "B (DOWN/REV)";
    }

    armCurrent = ramp(armCurrent, armTarget, ARM_STEP);
    Arm.spin(fwd, armCurrent, pct);

    //==================== INTAKE (independent) ====================
    const char* intakeText = "STOP";
    if (Controller.ButtonR2.pressing()) {
      Intake.spin(fwd, 100, pct);     // in
      intakeText = "R2 (IN)";
    } else if (Controller.ButtonR1.pressing()) {
      Intake.spin(fwd, -100, pct);    // out
      intakeText = "R1 (OUT)";
    } else {
      Intake.stop(hold);
    }

    //==================== HUD / DEBUG PRINTS ====================
    // Update a few times a second to avoid flicker/slowdown
    hudCounter++;
    if (hudCounter >= 5) { // 5 * 20ms = 100ms
      hudCounter = 0;

      Brain.Screen.clearScreen();
      Brain.Screen.setCursor(1, 1);
      Brain.Screen.print("DRIVE: Ax3=%3.0f Ax1=%3.0f  L=%3.0f R=%3.0f",
                         forward, turn, leftTarget, rightTarget);

      Brain.Screen.setCursor(2, 1);
      Brain.Screen.print("LIFT: mode=%s pos=%4.0f tgt=%4.0f pwr=%4.0f",
                         liftModeText, currentLiftPos, liftTargetPosition, liftCurrent);

      Brain.Screen.setCursor(3, 1);
      Brain.Screen.print("PRESETS: Up=%d Right=%d Down=%d  MANUAL: L1=%d L2=%d",
                         Controller.ButtonUp.pressing(),
                         Controller.ButtonRight.pressing(),
                         Controller.ButtonDown.pressing(),
                         Controller.ButtonL1.pressing(),
                         Controller.ButtonL2.pressing());

      Brain.Screen.setCursor(4, 1);
      Brain.Screen.print("ARM: %s  pwr=%4.0f", armText, armCurrent);

      Brain.Screen.setCursor(5, 1);
      Brain.Screen.print("INTAKE: %s", intakeText);
    }

    task::sleep(20);
  }
}


/*================== MAIN ==================*/
int main() {
   pre_auton();
   Competition.autonomous(autonomous);
   Competition.drivercontrol(usercontrol);


   while (true) {
       task::sleep(100);
   }
}




